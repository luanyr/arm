

#### ARM基本数据类型

1.Byte:字节，8bit;

2.Halfword:半字，16bit（半字必须与2字节边界对齐）；

3.Word:字，32bit（字必须与4字节边界对齐）。

存储器可以看作0-2^32-1的线性字节阵列。每个字节都有唯一的地址。

注意：

1. ARM系统结构v4以上版本支持以上3种数据类型，v4以前版本仅支持字节和字。
2. 当将这些数据类型中的任意一种声明成unsigned类型时，n位数据值表示范围为0~2^n^-1的非负数，通常使用二进制格式。
3. 当将这些数据类型的任意一种声明成signed类型时，n位数据值表示范围为-2^n-1^~2^n-1^-1的整数，使用二进制的补码格式。
4. 所有数据类型指令的操作数都是字类型的，如“ADD r1,r0,#0x1”中的操作数“0x1”就是以字类型数据处理的。
5. Load/Store 数据传输指令可以从存储器存取传输数据，这些数据可以是字节、半字、字。加载时自动进行字节或半字的零扩展或符号扩展。对应的指令分别为LDR/BSTRB(字节操作）、LDRH/STRH(半字操作）、LDR/STR(字操作）。
6. ARM指令编译后是4个字节（与字边界对齐）；Thumb指令编译后是2个字节（与半字边界对齐）。

#### ARM处理器工作模式

![图片](https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8SzIR6xML71YPLGQMYQAjuhzRhw0dvYlbvYWn2gReQb4znns9enoLzkrn7J69AAJDVn4R2xQbRZA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

ARM之所以设计出这么多种模式出来，就是为了**「应对CPU在运行时各种突发事件」**，比如要支持正常的应用程序的运行，在运行任何一个时间点又可能发生很多异常事件，比如：关机、收到网卡信息、除数为0、访问非法内存、解析到了非法指令等等，不光要能处理这些异常还要能够从异常中再返回到原来的程序继续执行。

1. 用户模式：用户模式是用户程序的工作模式，它运行在操作系统的用户态，它没有权限去操作其它硬件资源，只能执行处理自己的数据，也不能切换到其它模式下，要想访问硬件资源或切换到其它模式只能通过软中断或产生异常。
2. 系统模式：系统模式是特权模式，不受用户模式的限制。用户模式和系统模式共用一套寄存器，操作系统在该模式下可以方便的访问用户模式的寄存器，而且操作系统的一些特权任务可以使用这个模式访问一些受控的资源。
3. 一般中断模式：一般中断模式也叫普通中断模式，用于处理一般的中断请求，通常在硬件产生中断信号之后自动进入该模式，该模式为特权模式，可以自由访问系统硬件资源。
4. 快速中断模式：快速中断模式是相对一般中断模式而言的，它是用来处理对时间要求比较紧急的中断请求，主要用于高速数据传输及通道处理中。
5. 管理模式：管理模式是**「CPU上电后默认模式」**，因此在该模式下主要用来做系统的初始化，软中断处理也在该模式下，当用户模式下的用户程序请求使用硬件资源时通过软件中断进入该模式。
6. 终止模式：中止模式用于支持虚拟内存或存储器保护，当用户程序访问非法地址，没有权限读取的内存地址时，会进入该模式，linux下编程时经常出现的segment fault通常都是在该模式下抛出返回的。
7. 未定义模式：未定义模式用于支持硬件协处理器的软件仿真，CPU在指令的译码阶段不能识别该指令操作时，会进入未定义模式。
8. Monitor：是为了安全而扩展出的用于执行安全监控代码的模式；也是一种特权模式

除用户模式以外，其余的所有6种模式称之为非用户模式，或特权模式（Privileged Modes）；其中除去用户模式和系统模式以外的5种又称为异常模式（ExceptionModes），常用于处理中断或异常，以及需要访问受保护的系统资源等情况。

##### 模式切换

ARM微处理器的运行模式可以通过软件改变，也可以通过外部中断或异常处理改变。应用程序运行在用户模式下，当处理器运行在用户模式下时，某些被保护的系统资源是不能被访问的。

##### 异常

指由处理器执行指令导致原来运行程序的中止，异常与指令运行相关，是CPU执行程序产生的，是同步的，可分为精确异常和非精确异常。异常处理遵守严格的程序顺序，不能嵌套，只有当第一个异常处理完并返回后才能处理后续的异常。

要进入异常模式，一定要有异常源，ARM规定有7种异常源：

| 异常源   | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| Reset    | 上电时执行                                                   |
| Undef    | 当流水线中的某个非法指令到达执行状态时执行                   |
| SWI      | 当一个软中断指令被执行完的时候执行                           |
| Prefetch | 当一个指令被从内存中预取时，由于某种原因而失败，如果它能到达执行状态这个异常才会产生 |
| Data     | 如果一个预取指令试图存取一个非法的内存单元，这时异常产生     |
| IRQ      | 通常的中断                                                   |
| FIQ      | 快速中断                                                     |

#### ARM寄存器

![图片](https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8SzIR6xML71YPLGQMYQAjuQne27rauooLcCpibYPQWaib25fQ32j9Pyc4VodgibVJbfR9V3tiafmh5qA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

通用寄存器包括R0~R15,可以分为3类:

1. 未分组寄存器R0~R7
2. 分组寄存器R8~R14、R13(SP) 、R14(LR)
3. 程序计数器PC(R15)、R8_fiq-R12_fir为快中断独有

#### 指令流水线

ARM处理器使用简单的3级流水线：

（1）取指令 从寄存器装载一条指令。

（2）译码（decode） 识别被执行的指令，并为下一个周期准备数据通路的控制信号。在这一级，指令占有译码逻辑，不占用数据通路。

（3）执行 处理指令并将结果写回寄存器。

![图片](https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc8SzIR6xML71YPLGQMYQAjuwic4HAh4uPEpCI5nZNBkCbYaDYiaBA1zGYt16uQgaS9C7m2H3x71HyJA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

对于三级流水线，PC寄存器中存放的是预取指令的地址，并非正在执行的指令地址。对于thumb指令集正在执行的指令地址是PC-4因为thumb是16位指令集，每条指令是2字节。ARM指令集是PC-8因为ARM是32位指令集，每条指令是 4字节。
