

#### ARM汇编指令

##### GNU汇编书写格式

1.代码行中的注释符号

“@”整行注释 “#”语句分离符号

直接操作数前缀：#或$

2.全局标号

标号只能由a-z,A-Z,0-9,'.',_等（由点、字母、数字、下划线等组成，除局部标号外，不能以数字开头）字符组成，标号的后面加”：“。

3.局部标号

局部标号主要在局部范围内使用而且局部标号可以重复出现。它由两部组成开头是一个0-99直接的数字局部标号 后面加“:”

#### 伪操作

1.符号定义伪指令

| 标号    | 含义                                                         |
| :------ | :----------------------------------------------------------- |
| .global | 使得符号对连接器可见，变为对整个工程可用的全局变量           |
| _start  | 汇编程序的缺省入口是_ start标号,用户也可以在连接脚本文件中用ENTRY标志指明其它入口点. |
| .local  | 表示符号对外部不可见，只对本文件可见                         |

2.数据定义伪操作

数据定义伪操作一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化。常见的数据定义伪操作有如下几种：

| 标号                  | 含义                                                         |
| :-------------------- | :----------------------------------------------------------- |
| .byte                 | 单字节定义        0x12,‘a’,23   【必须偶数个】               |
| .short                | 定义2字节数据     0x1234,65535                               |
| .long /.word          | 定义4字节数据      0x12345678                                |
| .quad                 | 定义8字节    .quad   0x1234567812345678                      |
| .float                | 定义浮点数    .float   0f3.2                                 |
| .string/.asciz/.ascii | 定义字符串    .ascii  “abcd\0”,   注意：.ascii  伪操作定义的字符串需要每行添加结尾字符 '\0'，其他不需要 |
| .space/.skip          | 用于分配一块连续的存储区域并初始化为指定的值，如果后面的填充值省略不写则在后面填充为0; |
| .rept                 | 重复执行接下来的指令，以.rept开始，以.endr结束               |

3.if选择

语法结构

```
.if  logical-expressing 
  ……                                   
.else
  ……
.endif    
```

类似c语言里的条件编译 

4.macro宏定义

.macro，.endm 宏定义类似c语言里的宏函数 。

macro伪操作可以将一段代码定义为一个整体，称为宏指令。然后就可以在程序中通过宏指令多次调用该段代码。

语法格式：

```assembly
   .macro    {$label} 名字{$parameter{,$parameter}…}
    ……..code
   .endm
```



#### 杂项伪操作

| 标号     | 含义                                                         |
| :------- | :----------------------------------------------------------- |
| .global/ | 用来声明一个全局的符号                                       |
| .arm     | 定义一下代码使用ARM指令集编译                                |
| .thumb   | 定义一下代码使用Thumb指令集编译                              |
| .section | .section   expr   定义一个段。expr可以使.text  .data.  .bss  |
| .text    | .text {subsection}   将定义符开始的代码编译到代码段          |
| .data    | .data {subsection}   将定义符开始的代码编译到数据段,初始化数据段 |
| .bss     | .bss {subsection}   将变量存放到.bss段,未初始化数据段        |
| .align   | .align{alignment}{,fill}{,max}  通过用零或指定的数据进行填充来使当前位置与指定边界对齐 |
|          | .align  4   --- 16字节对齐 2的4次方                          |
|          | .align  (4)  --- 4字节对齐                                   |
| .org     | .org offset{,expr}   指定从当前地址加上offset开始存放代码，并且从当前地址到当前地址加上offset之间的内存单元，用零或指定的数据进行填充 |
| .extern  | 用于声明一个外部符号，用于兼容性其他汇编                     |
| .code 32 | 同.arm                                                       |
| .code 16 | 同.thumb                                                     |
| .weak    | 用于声明一个弱符号，如果这个符号没有定义，编译就忽略，而不会报错 |
| .end     | 文件结束                                                     |
| .include | .include “filename” 包含指定的头文件, 可以把一个汇编常量定义放在头文件中 |
| .equ     | 格式：.equ   symbol,   expression把某一个符号(symbol)定义成某一个值(expression).该指令并不分配空间，类似于c语言的 #define |
| .set     | 给一个全局变量或局部变量赋值，和.equ的功能一样               |

#### GNU伪指令

关键点：伪指令在编译时会转化为对应的ARM指令

1. ADR伪指令 ：该指令把标签所在的地址加载到寄存器中。ADR伪指令为小范围地址读取伪指令，使用的相对偏移范围：当地址值是字节对齐 (8位) 时，取值范围为-255～255，当地址值是字对齐 (32位) 时，取值范围为-1020～1020。语法格式:

```
   ADR{cond}   register,label
 ADR      R0,  lable
```

1. ADRL伪指令：将中等范围地址读取到寄存器中

ADRL伪指令为中等范围地址读取伪指令。使用相对偏移范围：当地址值是字节对齐时，取值范围为-64～64KB；当地址值是字对齐时，取值范围为-256～256KB

语法格式：

```
ADRL{cond}   register,label
ADRL        R0，lable
```

1. LDR伪指令: LDR伪指令装载一个32位的常数和一个地址到寄存器。语法格式：

```
LDR{cond}  register,=[expr|label-expr]
LDR    R0，=0XFFFF0000      ；mov r1,#0x12   对比一下
```

注意：（1）ldr伪指令和ldr指令区分 下面是ldr伪指令：

```
ldr r1,=val  @ r1 = val   是伪指令，将val标号地址赋给r1    
【与MDK不一样，MDK只支持ldr r1,=val】
```

下面是ldr指令：

```
ldr r2,val   @ r1 = *val    是arm指令,将标号val地址里的内容给r2
val: .word 0x11223344
```

（2）如何利用ldr伪指令实现长跳转

```
  ldr  pc，=32位地址
```

（3）编码中解决非立即数的问题 用arm伪指令ldr

```
ldr r0,=0x999   ；0x999  不是立即数，
```