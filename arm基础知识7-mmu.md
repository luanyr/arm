### mmu的概念以及原理

mmu是内存管理单元（memory management unit）。负责虚拟地址和物理地址之间的转化，内存保护和权限控制。

#### 为什么需要虚拟地址

1.进程地址空间不隔离，没有保护权限

为每个进程创建4GB的虚拟地址空间，然后将虚拟地址映射到物理地址，就可以保证不同的程序访问的物理地址隔离。

2.当内存空间不足时，要将其他程序暂时拷贝到硬盘，然后将新的程序装入内存，导致内存使用效率低

使用页面调度，不会造成大量数据装入装出

3.程序运行的地址不确定

从应用程序角度来看，进程的地址空间分布在虚拟地址0x00000000到进程大小的这段空间内，所以进程的运行地址也确定了。

好处：

1. 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区
2. 

#### mmu相关概念

##### 页/页帧/页表/页表项/TLB

页：mmu中虚拟地址（VA）到物理地址（PA）映射的最小单位，映射的最低粒度是单个虚拟页到物理页，页大小通常是4K，不能将某一页分成几块分别映射，必须页对页整体映射。

页帧：物理地址中的一页内存。

页表：也称转换表，描述mmu的映射规则，首地址存放在CPU的cp15:c2中，页表由很多页表项组组成。

页表项：简称PTE，是页表的组成单位，保存了虚拟地址到物理地址的转换关系和权限控制等内容，一个页表项占四个字节。

TLB：转换旁路缓冲器，简单说就是一个高速的cache,专门用来缓存频繁使用的页表项。

##### 页表的组成

页表负责va与pa之间的映射关系，arm mmu一般采用2级页表结构：`一级页表`(L1)和`二级页表`(L2)。

1.一级页表(L1): 页表中只有一个一级页表。通常把它叫做L1主页表(L1 master page table).一级页表将4GB的地址空间划分成了4096个1MB的段(section).也就是说它有4096个页表项(一个页表项占4byte的空间,所以一个一级页表就占4096*4byte=4KB的空间)。4096个页表项按其功能分为2种类型：
普通页表项: 此页表项中包含的是虚拟地址到物理地址的转换关系(即虚拟地址对应物理页帧的首地址).
指针页表项：此页表项中包含的是指向二级页表的指针。
2.二级页表(L2):由于一级页表的划分粒度是1MB,划分粒度太粗,所以需要使用二级页表来进行细分。一级页表通过L1指针页表项把它们两者链接了起来。MMU访问时就可以通过一级页表的L1指针页表项访问对应的二级页表。从这个关系我们可以看出,二级页表一般有多个,其数量等于L1指针页表项的数量。二级页表根据细分的粒度,又可以将分为下面几种类型(不同MMU对二级页表的划分可能不一致,但原理一致)：
小页表(small):小页表的页表项数量=1MB/4KB=256个。(一个页表项占4byte的空间,所以一个粗页表就占256*4byte=1KB的空间)。
大页表(large):大页表的页表项数量=1MB/64KB=64个。(一个页表项占4byte的空间,所以一个粗页表就占16*4byte=64byte的空间)。
不管是大页表还是小页表，它们里面的页表项都是普通页表项.包含的是虚拟地址到物理地址的转换关系.(即虚拟地址对应物理页帧的首地址)。
上面提到了页表项由4个字节组成，每种页表项的32bit内容格式都有区别,具体如下图:![页表项](https://img-blog.csdnimg.cn/2020031121182286.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMjc0NzE1,size_16,color_FFFFFF,t_70,#pic_center)

#### mmu基本工作原理和地址转换过程

当cpu发出一个读写请求，mmu收到该请求，先查看tlb中是否存在该转换关系，如果存在，转换完成，如果不存在需要用页表来查找，流程如下：

1.首先从cp15:c2中查找页表首地址，也就是L1的其实地址；

2.根据虚拟地址的bit[31:20]定位到`L1主页表`的具体的`页表项`上。比如bit[31:20]=0x008,则对应L1主页表中0~4095个列表项的第8个。bit[31:20]=0xFFF,对应第4095(0xFFF)个列表项。

3.确定了`L1主页表`中具体的`页表项`后,MMU根据`页表项`的bit[1:0]位判断是`普通页表项`还是`指针页表项`？如果是`普通页表项`。因为它包含转换关系,说明物理地址找到，转换流程完成。如果是`指针页表项`,那么MMU就根据指针指向的`二级页表`来继续查找。

4.在`二级页表`中,MMU又根据虚拟地址的bit[19:12](此处指4KB页表)定位到`二级页表`的具体的`页表项`上。比如bit[19:12]=0x008,则对应二级页表中0~255个列表项的第8个。因为`二级页表`的`页表项`是`普通页表项`，它包含转换关系,所以物理地址找到，转换流程完成。

5.在找到转换关系后,MMU就会将此转换关系缓存到TLB中,方便下次使用。

#### mmu的内存保护功能

可以在PTE条目中预留出几个比特，用于设置访问权限的属性，如禁止访问、可读、可写和可执行等。设好后，CPU访问一个VA时，MMU找到页表中对应PTE，把指令的权限需求与该PTE中的限定条件做比对，若符合要求就把VA转换成PA，否则不允许访问，并产生异常。

#### 操作系统和mmu

实际上MMU是为满足操作系统越来越复杂的内存管理而产生的。OS和MMU的关系简单说：
　　a.系统初始化代码会在内存中生成页表，然后把页表地址设置给MMU对应寄存器，使MMU知道页表在物理内存中的什么位置，以便在需要时进行查找。之后通过专用指令启动MMU，以此为分界，之后程序中所有内存地址都变成虚地址，MMU硬件开始自动完成查表和虚实地址转换。
　　 b.os初始化后期，创建第一个用户进程，这个过程中也需要创建页表，把其地址赋给进程结构体中某指针成员变量。即每个进程都要有独立的页表。

### 为什么虚拟内存比物理内存大

磁盘会分一部分空间作为交换，叫做交换空间（swap space），就是临时存储空间，物理内存不够用时就用它。CPU会将暂时不用的数据内容放到交换空间，等需要用时，在加载到物理内存中。所以**虚拟内存=物理内存+交换空间**。

### 为什么程序大小可以超过物理内存

**局限性原理**：程序运行在一较短时间内，程序的执行仅限于某一个部分，相应的，访问的存储空间也仅限于某个区域。

通过虚拟内存，将需要的页或段加载到内存，将暂时不需要的放在磁盘。程序在运行时，如果他需要的页或段已经在内存中，则继续运行下去。如果它需要的页面或段未在内存中，则由kernel发出缺页中断，此时kernel将利用请求调取页的功能将该部分调入内存中。
